"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time


def time_function_decorator(function):
    def wrapper(*args):
        start_time = time.time()
        delta_time = function(*args)
        stop_time = time.time()
        print(stop_time - start_time, '\n')
        return delta_time

    return wrapper


@time_function_decorator
def list_generator(values):  # O(n)
    return [i for i in range(0, values)]  # O(n)


@time_function_decorator
def dict_generator(values):  # O(n)
    return {i: None for i in range(0, values)}  # O(n)


print('решение пункта a) \n')
print('Заполняем список:')
my_lst = list_generator(999999)

print('Заполняем словарь:')
my_dct = dict_generator(999999)

"""
Словарь заполняеться дольше, чем список потому, что для словаря формируется структура hash-table.

"""


@time_function_decorator
def add_list(lst: list, el):  # O(n)
    for item in lst:  # O(n)
        if item == el:  # O(1)
            return item  # O(1)


@time_function_decorator
def add_dict(dct: dict, el):  # O(1)
    return dct[el]  # O(1)


print('решение пункта б) \n')
print('Получаем элемент списка:')
list_element = add_list(my_lst, 999998)

print('Получаем элемент словаря:')
dict_element = add_dict(my_dct, 999998)

"""
Получение элемента из словаря быстрее.
Для получения элемента списка (общая сложность O(n)) выполняется больше операций,
а получение элемента словаря (общая сложность O(1)) происходит за константное время - одну операцию.

"""


@time_function_decorator
def del_list(lst: list, el):  # O(n)
    lst.remove(el)  # O(n)


@time_function_decorator
def del_dict(dct: dict, el):  # O(1)
    del dct[el]  # O(1)


print('решение пункта c) \n')
print('Удаляем элемент списка:')
del_list(my_lst, 999998)

print('Удаляем элемент словаря:')
del_dict(my_dct, 999998)

"""
Удаление элемента из словаря происходит быстрее (общая сложность O(1)),
а удаление элемента из списка происходит медленнее (общая сложность O(n)) 
орять же потому, что приходиться делать больше операций.

"""
